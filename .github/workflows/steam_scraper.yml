name: Steam Lua Progress Collector ğŸ“Š

on:
  workflow_dispatch:
    inputs:
      github_token:
        description: 'GitHub Token'
        required: true
      search_target:
        description: 'å…¨ç½‘æœç´¢ç›®æ ‡æ•°é‡'
        required: true
        default: '50'
  schedule:
    - cron: '0 16 * * *'

permissions:
  contents: write

jobs:
  progress-job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout (Fetch depth=1)
        uses: actions/checkout@v3
        with:
          fetch-depth: 1

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'

      - name: Install Dependencies
        run: |
          pip install PyGithub requests

      - name: Run Script with Progress Bar
        env:
          USER_INPUT_TOKEN: ${{ inputs.github_token }}
          SEARCH_TARGET: ${{ inputs.search_target || '20' }}
        run: |
          cat << 'EOF' > collector.py
          import os
          import time
          import shutil
          import subprocess
          import requests
          import concurrent.futures
          from github import Github, Auth, RateLimitExceededException

          # === é…ç½® ===
          SEARCH_TARGET = int(os.environ.get('SEARCH_TARGET', 20))
          TOKEN = os.environ.get('USER_INPUT_TOKEN')
          SAVE_DIR = "lua_downloads"
          MARKER_FILE = ".luatool_imported"
          
          LUATOOL_REPO = "https://github.com/usercat280297/Luatool.git"
          MANIFEST_REPO = "https://github.com/SteamAutoCracks/ManifestHub.git"

          search_added_count = 0

          # å¼ºåˆ¶åˆ·æ–°æ—¥å¿—
          def log(msg):
              print(f"[System] {msg}", flush=True)

          def ensure_dir(path):
              if not os.path.exists(path):
                  os.makedirs(path)

          def is_numeric_lua(filename):
              if not filename.endswith('.lua'): return False
              return filename[:-4].isdigit()

          # === Git å·¥å…· (é™éŸ³ + è¶…æ—¶) ===
          def git_run(args, cwd=None, timeout=30):
              try:
                  subprocess.run(
                      args, cwd=cwd, check=True, 
                      stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, 
                      timeout=timeout
                  )
                  return True
              except:
                  return False

          # === 1. å…¨ç½‘æœç´¢ (ä¿®å¤ Auth è­¦å‘Š) ===
          def check_and_download_file(file_info):
              raw_url, filename, repo_name = file_info
              save_path = os.path.join(SAVE_DIR, filename)
              if os.path.exists(save_path): return False
              try:
                  resp = requests.get(raw_url, timeout=5)
                  if resp.status_code == 200 and 'addappid' in resp.text:
                      if not os.path.exists(save_path):
                          with open(save_path, 'w', encoding='utf-8') as f:
                              f.write(resp.text)
                          return True
              except: pass
              return False

          def process_repo_search():
              global search_added_count
              if not TOKEN: 
                  log("æ—  Tokenï¼Œè·³è¿‡æœç´¢")
                  return

              log(f"--- å¯åŠ¨å…¨ç½‘æœç´¢ (ç›®æ ‡: {SEARCH_TARGET}) ---")
              # ä½¿ç”¨æ–°çš„ Auth æ–¹å¼ï¼Œæ¶ˆé™¤è­¦å‘Š
              auth = Auth.Token(TOKEN)
              g = Github(auth=auth)
              
              try:
                  repos = g.search_repositories(query="steam OR manifest language:Lua", sort="updated", order="desc")
                  scanned = 0
                  for repo in repos:
                      if search_added_count >= SEARCH_TARGET or scanned >= 80: break
                      scanned += 1
                      if os.environ.get("GITHUB_REPOSITORY") == repo.full_name: continue

                      try:
                          tree = repo.get_git_tree(repo.default_branch, recursive=True).tree
                          candidates = []
                          for element in tree:
                              fname = os.path.basename(element.path)
                              if is_numeric_lua(fname) and not os.path.exists(os.path.join(SAVE_DIR, fname)):
                                  candidates.append((f"https://raw.githubusercontent.com/{repo.full_name}/{repo.default_branch}/{element.path}", fname, repo.full_name))

                          if candidates:
                              with concurrent.futures.ThreadPoolExecutor(max_workers=10) as executor:
                                  results = list(executor.map(check_and_download_file, candidates))
                              added = sum(results)
                              if added > 0:
                                  search_added_count += added
                                  log(f"âœ… {repo.full_name} è´¡çŒ®äº† {added} ä¸ª")
                      except: continue
              except Exception as e:
                  log(f"æœç´¢ä¸­æ–­: {e}")

          # === 2. Luatool (ä¿æŒä¸å˜) ===
          def process_luatool():
              if os.path.exists(MARKER_FILE):
                  log("Luatool å·²å®Œæˆï¼Œè·³è¿‡")
                  return
              log("--- å¤„ç† Luatool ---")
              temp_dir = "temp_luatool"
              count = 0
              if os.path.exists(temp_dir): shutil.rmtree(temp_dir)
              if git_run(["git", "clone", "--depth=1", LUATOOL_REPO, temp_dir]):
                  src_dir = os.path.join(temp_dir, "lua_files")
                  if os.path.exists(src_dir):
                      for fname in os.listdir(src_dir):
                          if is_numeric_lua(fname):
                              dst = os.path.join(SAVE_DIR, fname)
                              if not os.path.exists(dst):
                                  try:
                                      with open(os.path.join(src_dir, fname), 'r', encoding='utf-8', errors='ignore') as f:
                                          if 'addappid' in f.read():
                                              shutil.copy2(os.path.join(src_dir, fname), dst)
                                              count += 1
                                  except: pass
                  with open(MARKER_FILE, 'w') as f: f.write("done")
                  log(f"Luatool æ–°å¢: {count}")
              shutil.rmtree(temp_dir, ignore_errors=True)

          # === 3. ManifestHub (å¸¦è¿›åº¦æ¡ç‰ˆ) ===
          def process_manifesthub():
              log("--- å¤„ç† ManifestHub ---")
              count = 0
              temp_repo = "temp_manifest"
              
              try:
                  log("æ­£åœ¨è·å–è¿œç¨‹åˆ†æ”¯åˆ—è¡¨...")
                  ls_proc = subprocess.run(
                      ["git", "ls-remote", "--heads", MANIFEST_REPO], 
                      capture_output=True, text=True, timeout=30
                  )
                  
                  branches = []
                  for line in ls_proc.stdout.splitlines():
                      parts = line.split('\t')
                      if len(parts) > 1:
                          b = parts[1].replace('refs/heads/', '')
                          if b.isdigit() and not os.path.exists(os.path.join(SAVE_DIR, f"{b}.lua")):
                              branches.append(b)

                  total_files = len(branches)
                  if total_files == 0:
                      log("ManifestHub æ— æ–°æ–‡ä»¶")
                      return

                  log(f"ManifestHub å‘ç° {total_files} ä¸ªæ–°æ–‡ä»¶å¾…ä¸‹è½½")

                  if not os.path.exists(temp_repo):
                      os.makedirs(temp_repo)
                      git_run(["git", "init", temp_repo])
                      git_run(["git", "-C", temp_repo, "remote", "add", "origin", MANIFEST_REPO])

                  # === è¿›åº¦æ¡é€»è¾‘ ===
                  batch_size = 50
                  processed_count = 0
                  
                  for i in range(0, total_files, batch_size):
                      batch = branches[i:i+batch_size]
                      
                      # ä¸‹è½½è¿™ä¸€æ‰¹
                      if git_run(["git", "-C", temp_repo, "fetch", "origin"] + batch + ["--depth=1"], timeout=60):
                          for branch in batch:
                              try:
                                  # æå–æ–‡ä»¶
                                  proc = subprocess.run(
                                      ["git", "-C", temp_repo, "show", f"FETCH_HEAD:{branch}.lua"], 
                                      capture_output=True, text=True, errors='ignore', timeout=5
                                  )
                                  content = proc.stdout
                                  # å¤‡ç”¨æŸ¥æ‰¾
                                  if not content:
                                      ls = subprocess.run(["git", "-C", temp_repo, "ls-tree", "-r", "--name-only", "FETCH_HEAD"], capture_output=True, text=True, timeout=5).stdout
                                      if ls:
                                          for f in ls.splitlines():
                                              if f.endswith('.lua'):
                                                  content = subprocess.run(["git", "-C", temp_repo, "show", f"FETCH_HEAD:{f}"], capture_output=True, text=True, errors='ignore', timeout=5).stdout
                                                  break
                                  
                                  if content and 'addappid' in content:
                                      with open(os.path.join(SAVE_DIR, f"{branch}.lua"), 'w', encoding='utf-8') as f:
                                          f.write(content)
                                      count += 1
                              except: pass
                      
                      # æ›´æ–°è¿›åº¦
                      processed_count += len(batch)
                      percent = (processed_count / total_files) * 100
                      
                      # æ¯ 10 æ‰¹æ¬¡ (çº¦500ä¸ªæ–‡ä»¶) æ‰“å°ä¸€æ¬¡æ—¥å¿—ï¼Œé¿å…åˆ·å±å¤ªå¿«
                      # æˆ–è€…å¦‚æœåˆ°äº†æœ€åä¸€æ‰¹ï¼Œå¼ºåˆ¶æ‰“å°
                      if (i // batch_size) % 10 == 0 or processed_count >= total_files:
                          bar_length = 20
                          filled_length = int(bar_length * processed_count // total_files)
                          bar = 'â–ˆ' * filled_length + 'â–‘' * (bar_length - filled_length)
                          log(f"è¿›åº¦: {bar} {percent:.1f}% ({processed_count}/{total_files})")

                  log(f"ManifestHub åŒæ­¥å®Œæˆï¼Œå®é™…æ–°å¢: {count}")

              except Exception as e:
                  log(f"ManifestHub é”™è¯¯: {e}")
              finally:
                  shutil.rmtree(temp_repo, ignore_errors=True)

          # === æ‰§è¡Œ ===
          ensure_dir(SAVE_DIR)
          process_repo_search()
          process_luatool()
          process_manifesthub()
          log("æ‰€æœ‰ä»»åŠ¡æ‰§è¡Œå®Œæ¯•")
          EOF

          python collector.py

      - name: Commit and Push
        run: |
          git config --global user.name "AutoBot"
          git config --global user.email "bot@github.com"
          git add lua_downloads/
          if [ -f .luatool_imported ]; then git add .luatool_imported; fi
          git commit -m "Auto update files" || echo "No changes"
          git push
